{
  parserClass="ru.mse.itmo.lama.language.parser.LamaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="LamaWTF"
  psiImplClassSuffix="ImplWTF"
  psiPackage="ru.mse.itmo.lama.language.psi"
  psiImplPackage="ru.mse.itmo.lama.language.psi.impl"

  elementTypeHolderClass="ru.mse.itmo.lama.language.psi.LamaTypes"
  elementTypeClass="ru.mse.itmo.lama.language.psi.LamaElementType"
  tokenTypeClass="ru.mse.itmo.lama.language.psi.LamaTokenType"

  tokens=[
    // Section keywords
    after='after'
    esac='esac'
    infixl='infixl'
    syntax='syntax'
    array='array'
    eta='eta'
    infixr='infixr'
    then='then'
    at='at'
    false='false'
    lazy='lazy'
    true='true'
    before='before'
    fi='fi'
    od='od'
    val='val'
    box='box'
    for='for'
    of='of'
    var='var'
    case='case'
    fun='fun'
    public='public'
    while='while'
    do='do'
    if='if'
    sexp='sexp'
    elif='elif'
    import='import'
    skip='skip'
    else='else'
    infix='infix'
    str='str'

    // Section 2.1.1
    space='regexp:\s+'
    singleComment='regexp:--'
    multiComment='regexp:\(\*.*?\*\)'

    // Section 2.1.2
    uident='regexp:[A-Z][a-zA-Z_0-9]*'
    lident='regexp:[a-z][a-zA-Z_0-9]*'
    decimal='regexp:-?[0-9]+'
    string="regexp:\"([^\"\\]|\\.)*\""
    char="regexp:'([^']|''|\n|\t)'"

    infixop="regexp:[+*/%$#@!|&\^?<>:=\\-]+"
  ]
//
//  name(".*expr")='expression'
//  extends(".*expr")=expr
}

compilation_unit ::= importRule * scopeExpression
importRule ::= import uident ';'
scopeExpression ::= definition * [expression]
definition ::= variableDefinition | functionDefinition | infixDefinition
variableDefinition ::= (var | public) variableDefinitionSeq ';'
variableDefinitionSeq ::= variableDefinitionItem (',' variableDefinitionItem) *
variableDefinitionItem ::= lident ['=' expression]
functionDefinition ::= [public] fun lident '(' functionArguments ')' functionBody
functionArguments ::= [lident (',' lident) *]
functionBody ::= '{' scopeExpression '}'

infixDefinition ::= infixHead '(' functionArguments ')' functionBody
infixHead ::= [public] infixity infixop level
infixity ::= infix | infixl | infixr
level ::= [at | before | after] infixop

// TODO
expression ::= primary

primary ::=
    decimal            |
    string             |
    char               |
    lident             |
    listExpression     |
    arrayExpression    |
    sExpression        |
    ifExpression       |
    whileDoExpression

listExpression ::=
    "[" [expression ("," expression)*] "]"

arrayExpression ::=
    "{" [expression ("," expression)*] "}"

sExpression ::=
    uident ["(" [expression ("," expression)*] ")"]

ifExpression ::=
    if expression then scopeExpression [ elsePart ] fi

elsePart ::= elif expression then scopeExpression [ elsePart ] | else scopeExpression

whileDoExpression ::= while expression do scopeExpression od

//private root_item ::= !<<eof>> property ';' {pin=1 recoverWhile=property_recover}
//
//property ::= (uident|lident) '=' expr  {pin=2}
//private property_recover ::= !(';' | id '=')
//
//expr ::= factor plus_expr *
//left plus_expr ::= plus_op factor
//private plus_op ::= '+'|'-'
//private factor ::= primary mul_expr *
//left mul_expr  ::= mul_op primary
//private mul_op ::= '*'|'/'
//private primary ::= primary_inner factorial_expr ?
//left factorial_expr ::= '!'
//private primary_inner ::= literal_expr | ref_expr | paren_expr
//paren_expr ::= '(' expr ')' {pin=1}
//ref_expr ::= id
//literal_expr ::= number | string | float | char
