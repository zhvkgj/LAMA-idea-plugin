{
  parserClass="ru.mse.itmo.lama.language.parser.LamaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="LamaWTF"
  psiImplClassSuffix="ImplWTF"
  psiPackage="ru.mse.itmo.lama.language.psi"
  psiImplPackage="ru.mse.itmo.lama.language.psi.impl"

  elementTypeHolderClass="ru.mse.itmo.lama.language.psi.LamaTypes"
  elementTypeClass="ru.mse.itmo.lama.language.psi.LamaElementType"
  tokenTypeClass="ru.mse.itmo.lama.language.psi.LamaTokenType"

  tokens=[
    // Section: keywords
    after='after'
    esac='esac'
    infixl='infixl'
    syntax='syntax'
    array='array'
    eta='eta'
    infixr='infixr'
    then='then'
    at='at'
    false='false'
    lazy='lazy'
    true='true'
    before='before'
    fi='fi'
    od='od'
    val='val'
    box='box'
    for='for'
    of='of'
    var='var'
    case='case'
    fun='fun'
    public='public'
    while='while'
    do='do'
    if='if'
    sexp='sexp'
    elif='elif'
    import='import'
    skip='skip'
    else='else'
    infix='infix'
    str='str'

    // Section: whitespaces and comments
    space='regexp:\s+'
    singleComment='regexp:--[^\r\n]*'
    multiComment='regexp:\(\*.*?\*\)'

    // Section: general tokens
    uident='regexp:[A-Z][a-zA-Z_0-9]*'
    lident='regexp:[a-z][a-zA-Z_0-9]*'
    decimal='regexp:-?[0-9]+'
    string="regexp:\"([^\"\\]|\\.)*\""
    char="regexp:'([^']|''|\n|\t)'"

    // Section: delimiters
    dot='.'
    comma=','
    lb='('
    rb=')'
    curlylb='{'
    curlyrb='}'
    semicolon=';'
    sharp='#'
    hence='->'
    alt='|'

    // Section
    squarelb='['
    squarerb=']'
    wildcard='_'

    // Section: infix operators
    disj="!!"
    conj="&&"
    eq="regexp:(==|!=)"
    comp="regexp:(<=|<|>|>=)"
    add="regexp:[+-]"
    mul="regexp:[*/%]"

    infixop="regexp:[+*/%$#@!|&^?<>:=\\-]+"
  ]
}

compilationUnit ::= importRule * scopeExpression

importRule ::= import uident semicolon

scopeExpression ::= definition * [ expression ]

definition ::=
    variableDefinition
    | functionDefinition
    | infixDefinition

variableDefinition ::= ( var | public ) variableDefinitionSeq semicolon

variableDefinitionSeq ::= variableDefinitionItem ( comma variableDefinitionItem ) *

variableDefinitionItem ::= lident [ '=' basicExpression ]

functionDefinition ::= [ public ] fun lident lb functionArguments rb functionBody

functionArguments ::= [ functionArgument ( comma functionArgument ) * ]

functionArgument ::=
    lident |
    pattern

functionBody ::= curlylb scopeExpression curlyrb

infixDefinition ::= infixHead lb functionArguments rb functionBody

infixHead ::= [ public ] infixity infixop level

infixity ::=
    infix
    | infixl
    | infixr

level ::= [ at | before | after ] infixop

expression ::= basicExpression [ semicolon expression ]

basicExpression ::= disjunction

disjunction ::= conjunction ( disj conjunction ) *

conjunction ::= equality ( conj equality ) *

equality ::= comparison (eq comparison ) *

comparison ::= additive ( comp additive ) *

additive ::= multiplicative ( add multiplicative ) *

multiplicative ::= customOperatorExpression ( mul customOperatorExpression ) *

customOperatorExpression ::= dotNotation ( infixop dotNotation ) *

dotNotation ::= postfixExpression ( dot (functionCall | lident) ) *

//multiplicative ::= postfixExpression

postfixExpression ::=
    primary      |
    functionCall |
    arrayIndexing

functionCall ::=
    postfixExpression lb [ expression ( comma expression ) * ] rb {extends=postfixExpression}

arrayIndexing ::=
    postfixExpression squarelb expression squarerb {extends=postfixExpression}

// TODO: case expression
primary ::=
    decimal                 |
    string                  |
    char                    |
    lident                  |
    true                    |
    false                   |
    infix                   |
    skip                    |
    lb scopeExpression rb   |
    listExpression          |
    arrayExpression         |
    sExpression             |
    ifExpression            |
    whileDoExpression       |
    doWhileExpression       |
    forExpression           |
    caseExpression
    {extends=postfixExpression}

listExpression ::=
    curlylb [ expression ( comma expression ) * ] curlyrb

arrayExpression ::=
    squarelb [ expression ( comma expression ) * ] squarerb

sExpression ::=
    uident [ lb expression [ ( comma expression ) * ] rb ]

ifExpression ::=
    if expression then scopeExpression [ elsePart ] fi

elsePart ::=
    elif expression then scopeExpression [ elsePart ] |
    else scopeExpression

whileDoExpression ::= while expression do scopeExpression od

doWhileExpression ::= do scopeExpression while expression od

forExpression ::=
    for scopeExpression comma expression comma expression do scopeExpression od

caseExpression ::= case expression of caseBranches esac

caseBranches ::= caseBranch [ ( alt caseBranch ) * ]

caseBranch ::= pattern hence scopeExpression

pattern ::=
    consPattern
    | simplePattern

consPattern ::= simplePattern  ':' pattern

simplePattern ::=
    wildcardPattern
    | sExprPattern
    | arrayPattern
    | listPattern
    | lident [ '@' pattern ]
    | [ '-' ] decimal
    | string
    | char
    | true
    | false
    | sharp box
    | sharp val
    | sharp str
    | sharp array
    | sharp sexp
    | sharp fun
    | lb pattern rb

wildcardPattern ::= wildcard

sExprPattern ::= uident [ lb pattern ( comma pattern ) * rb ]

arrayPattern ::= squarelb [ pattern ( comma pattern ) * ] squarerb

listPattern ::= curlylb [ pattern ( comma pattern ) * ] curlyrb
